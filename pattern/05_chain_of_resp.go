package pattern

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

// Цепочка вызовов - поведенческий паттерн, суть заключается в передаче запроса по цепочке потенциальных обработчиков, пока один из них, или каждый, не обработает запрос.
/*
Использование:
	1) когда программа должна обрабатывать разнообразные запросы несколькими способами,
	но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся
	2) когда важно, чтобы обработчики выполнялись один за другим в строгом порядке
	3) когда набор объектов, способных обработать запрос, должен задаваться динамически

	+:
	1) уменьшает зависимость между клиентом и обработчиками
	2) реализует принцип единственной обязаности
		Каждый обработчик ответсвенен за свою область
	3) реализует принцип открытости/закрытости
	4) Выстраивание цепи обработки на свое усмотрение


	-:
	1) запрос может остаться никем не обработанным
*/

type Handler interface {
	SetNext(Handler)
	Execute(string)
}

type SomeHandler struct {
	name string
	next Handler
}

func (sh *SomeHandler) SetNext(next Handler) {
	sh.next = next
}

func (sh *SomeHandler) Execute(name string) {
	println(sh.name, " обрабатывает запрос")
	if sh.next != nil {
		sh.next.Execute(name)
	}
}

func main() {
	//создаём обработчиков запроса
	handler1 := &SomeHandler{name: "Обработчик 1"}
	handler2 := &SomeHandler{name: "Обработчик 2"}
	handler3 := &SomeHandler{name: "Обработчик 3"}

	// формируем цепочку вызовов
	handler1.SetNext(handler2)
	handler2.SetNext(handler3)

	// посылаем запрос первому обработчику
	handler1.Execute("GO! GO! GO!")
}
